#!/bin/bash

know_branch() {
    export BRANCH="$(command git 2>/dev/null branch --list | sed -n 's/^\* //p')" >/dev/null 2>/dev/null
    [[ -r "$APPL/config/database.yml" ]] && eval $(perl -ne 'print "export DBNAME=$1\n" if (/^development:/ ... /^\S/) && /^\s+database:\s*(\w+)/' "$APPL/config/database.yml") >/dev/null 2>/dev/null
}  # know_branch


git() {
    local call=git exit=0 loopable= iflag= mflag= at_top= in_proj=

    # detect PWD is the top of all tickit projects, and collect list if so
    if [[ -n "$APPL_TOP" ]]; then
        if [[ "$PWD" == "$APPL_TOP" ]]; then
            at_top=1
            tops=(@(@(rel-|v)+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z])))
        elif [[ "$PWD" == "$APPL_TOP"/@(@(rel-|v)+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z]))?(/*) ]]; then
            in_proj=1
        fi
    fi

    # parameters! WOOO!
    while true; do
        if [[ "X$1" == X-i ]]; then
            iflag=1
            shift
            continue
        fi

        # if at top, then -L name name name ... limits interesting projects to those names
        if [[ -n "$at_top" && "X$1" == X-L ]]; then
            shift
            tops=()
            while [[ "$1" == @(@(rel-|v)+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z])) ]]; do
                tops+=("$1")
                shift
            done
            continue
        fi

        break
    done

    cmd="$1"
    shift
    if [[ "$cmd" != help && "$1" == help ]]; then
        # report on a confused attempt to get help
        echo >&2 "You probably mean git $(tput setaf 3)$cmd --help ...$(tput sgr0) or $(tput setaf 3)git help $cmd ...$(tput sgr0)"
        call= exit=1
    elif [[ "$cmd" == @(huh|status|fetch|push|pull|pulla|jones) ]]; then
        # detect git subcommands (including special ons in this script) wot are applicable in a loopy style from the top directory
        loopable=1
    elif [[ "$cmd" == branch ]]; then
        # this one is also top-loopable in certain circumstances
        if [[ $# -eq 0 ]] || [[ $# -eq 1 && "X$1" == X-a ]]; then
            loopable=1
        fi
    fi

    ((exit==0)) || return $exit

    # if the command is loopable (and at top) start looping
    if [[ -n "$at_top" && -n "$loopable" ]]; then
        local HERE="$PWD"
        local OAPPL="$APPL"
        trap 'cd "$HERE"; [[ -n "$OAPPL" ]] && app -n "${OAPPL##*/}"' RETURN HUP INT QUIT TERM

        local _first=1  # tracker used to help insert polite blank lines appropriately
        for _d in "${tops[@]}"; do
            # directory must exist - bad tpyngi for -L list can exit in crap...
            if ! [[ -d "$HERE/$_d" ]]; then
                echo >&2 "WARNING: project directory $_d does not exist or is not a directory."
                ((exit)) || exit=1
                continue
            fi

            # directory must not have .gitskip - except for 2 lucky commands
            [[ "$cmd" != @(status|branch) && -f "$HERE/$_d/.gitskip" ]] && continue

            # interactive? By your leave, your liege...
            if [[ -n "$iflag" ]]; then
                while
                  read -p "Perform git $cmd on $_d? " || { echo; break 2; }

                  case "$REPLY" in
                    [yY]*) break;;
                    [nN]*) continue 2;;
                    [qQ]*) break 2;;
                  esac
                do
                    echo "Make a choice!"
                done
            fi

            cd "$HERE/$_d" || {
                echo >&2 "WARNING: cannot cd into project directory $_d"
                ((exit)) || exit=1
                continue
            }

            ((_first)) || echo
            _first=0
            echo '$APPL_TOP/'"$_d:"

            # recursive GIT time! Also, capture highest error exit for exit status of this function.
            git $cmd "$@" | sed '/./s/^/  /'
            x=$?
            ((exit < x)) && exit=$x
            cd "$HERE"
        done

        return $exit
    fi
    # That's the end of all the loopy excitement.

    case "$cmd" in
      huh)
        # Status command for this directory only.
        cmd=
        set -- status "$@" .
        ;;

      spawn)        # git spawn [-m] tod-<number>
        know_branch >/dev/null 2>/dev/null
        if ! git pulla; then
            exit=1
            break
        fi

        if [[ "X$1" == X-m ]]; then
            shift
            mflag=-m
        fi

        if [[ $# -ne 1 || "$1" != tod-+([0-9])*([a-z]) ]]; then
            echo >&2 "usage: git spawn [-m] tod-something"
            exit=1
        fi

        if git push origin "$BRANCH":"$1" && git fetch && git checkout $mflag --track -b "$1" origin/"$1"
          then call=
          else exit=0
        fi
        ;;

      pulla)
        # pull for all known branches in this project.

        # Block pulla if there's uncommitted changes, 'cos shit happens...
        if git status --porcelain | sed 's/^ /./; s/^\(.\)\(.\) \(.*\)$/\1 \2 \3/; /^[?!]/d' | grep -q .; then
            echo >&2 "Significant uncommitted work exists - cannot-a pull-a da project-as"
            exit=1
        else
            command git branch | sed 's/^ /-/' | {
                this=
                while read state name; do
                    [[ $state == '*' ]] && this="$name"
                    ( command git checkout "$name" && command git pull "$@" )
                done
                [[ -n "$this" ]] && command git checkout "$this" 2>&-
            }

            # ooops - looks like we can't gather error status from all the pulls. Bash is too sucky
            call= exit=0
        fi
        ;;

      jones)      # as in, keeping up with...
        call=

        # Detect all branches in this project. Wait for it, you'll find out why...
        # The sed is making the output of git branch a bit more regular so it's easy to parse with dumb shell.
        command git branch | sed 's/^ /-/; s/^\(.\) \(.*\)/\2 \1/' | sort | {
            typeset -a branches
            this=

            # Gather list of branches and their statii.
            while read name state; do
                [[ "$state" == '*' ]] && this="$name"
                branches+=("$name")
            done

            # Assuming there's 2 branches...
            main="${branches[0]}"
            dev="${branches[1]}"

            # Merge the branch if it's alone in this project with a release branch.
            if [[ "${#branches[@]}" -eq 2 && "$this" == tod-+([0-9])*([a-z]) ]] && [[ "$main" == rel-+([0-9])+(.+([0-9]))*([a-z]) && "$dev" == tod-+([0-9])*([a-z]) ]]; then
                # Proven:
                #  This directory only has 2 local branches: a release (branch it's following) and a development branch.
                #  Current branch is the development branch.

                if git status --porcelain | sed 's/^ /./; s/^\(.\)\(.\) \(.*\)$/\1 \2 \3/; /^[?!]/d' | grep -q .; then
                    echo >&2 "Significant uncommitted work exists - cannot merge release $main"
                else
                    echo "Merging from origin/$main"
                    git merge -X patience "origin/$main"
                fi
            fi
        }
        ;;

      branch)
        if [[ "$1" == @(list|merge|merged|track|delete|move|rename) ]]; then
            echo >&2 "Not allowing $(tput setaf 3)git branch $1$(tput sgr0)! Do you mean one of --list --merged --track -d -D -M -m ?"
            call= exit=1
        fi
        ;;

      ls)
        # Same as ls but limited to files that git knows about that are changed.
        call=
        (
            [[ -n "$in_proj" ]] && cd "$APPL"
            ls -1 "$@" $(command \git status --porcelain | perl -ne 'print "$2\n" if /^([MADRCU].|.[MADRCU]) (.*)$/;' | sort -u)
        )
        ;;

      lsa)
        # Same as ls but limited to files that git claims are changed or new.
        call=
        (
            [[ -n "$in_proj" ]] && cd "$APPL"
            ls -1 "$@" $(command \git status --porcelain | perl -ne 'next if / \.gitskip$/; print "$2\n" if /^([?MADRCU].|.[?MADRCU]) (.*)$/;' | sort -u)
        )
        ;;

      duff)
        cmd=diff
        set -- --patience --minimal -w --word-diff=color "$@"
        ;;

      stash)
        if [[ "$1" != @(list|show|drop|pop|apply|branch|save|clear|create) ]]; then
            echo >&2 "Not allowing $(tput setaf 3)git stash$(tput sgr0) without a sub-command! Do you mean list, show or save, or do you mean drop, pop, apply, branch, clear or create?"
            call= exit=1
        fi

        ## if [[ "$1" == save ]] && [[ $# -lt 3 || ${!#} == -* ]]; then
        ##     echo >&2 "Try putting a message that means something to you, tiger!"
        ##     call= exit=1
        ## fi
        ;;
    esac

    if ((exit==0)) && [[ -n "$call" ]]; then (
        [[ "$cmd" == status && -n "$in_proj" ]] && cd "$APPL"
        command $call $cmd "$@"
        exit=$?
    ); fi

    know_branch >/dev/null 2>/dev/null      # know it in the biblical sense
    return $exit
}  # git


app_usage() {
   echo >&2 "usage: app [-l] [-n] [-v] [-N] [-M|-V|-C|-H|-L|-P] [project]"
   [[ $# -gt 0 ]] && echo >&2 "$@"
   return 1
}  # app_usage


app() {
    local nflag= vflag= lflag= Nflag=
    local Mflag= Vflag= Cflag= Hflag= Lflag Pflag
    local OPTIND=1

    while getopts :lnvNMVCHLP ch; do
      case "$ch" in
        l) lflag=1 ;;   # list available apps
        n) nflag=1 ;;   # no move - just echo or set
        v) vflag=1 ;;   # verbalise
        N) Nflag=1 ;;   # go Native - make the current branch match the project

        [MVCHLP]) eval ${ch}flag=${ch} ;;

        *) app_usage; return
      esac
    done
    shift $((OPTIND-1))

    case "$Mflag$Vflag$Cflag$Hflag$Lflag$Pflag" in
      ??*)
        app_usage "-M, -V, -C, -H, -L, and -P are mutually exclusive"; return
    esac

    if [[ -n "$nflag" && -n "$Mflag$Vflag$Cflag$Hflag$Lflag$Pflag" ]]; then
        app_usage "Cannot use -n with -M, -V, -C, -H, -L, or -P"; return
    fi

    if [[ -z "$APPL_TOP" ]]; then
        app_usage "Cannot find \$APPL_TOP environment variable"; return
    fi

    if [[ ! -d "$APPL_TOP" ]]; then
        app_usage "Cannot find $APPL_TOP directory"; return
    fi

    if [[ -n "$lflag" ]]; then
        if [[ -n "$nflag$Nflag" || $# -gt 0 ]]; then
            app_usage "Cannot use -l with -n, -N or a named project"; return
        fi

        ls 2>&- -d "$APPL_TOP"/@(@(rel-|v)+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z])) | sed 's:.*/::' |
        {
          first=yo
          while read app; do
              if [[ -z "$vflag" ]]; then
                  echo $app
              else
                  if [[ -n "$first" ]]
                    then first=
                    else echo
                  fi

                  echo "$app:"
                  ( \cd "$APPL_TOP/$app" && git branch | sed 's/^/  /' )
              fi
          done
        }

        return 0
    fi

    if [[ -n "$Nflag" ]]; then
        if [[ -n "$nflag$vflag" || $# -gt 0 ]]; then
            app_usage "Cannot use -N with -n or a named project"; return
        fi

        if [[ "$PWD" != "$APPL_TOP"/@(@(rel-|v)+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z]))?(/*) ]]; then
            app_usage "'app -N' only works if you are in a Tickit project"; return
        fi

        local xxx="${PWD#$APPL_TOP/}"
        xxx="${xxx%%/*}"
        git checkout -m "$xxx"
        return 0
    fi

    target=
    case "$Mflag$Vflag$Cflag$Hflag$Lflag$Pflag" in
      M) target=/app/models      ;;
      V) target=/app/views       ;;
      C) target=/app/controllers ;;
      H) target=/app/helpers     ;;
      L) target=/lib             ;;
      P) target=/public          ;;
    esac

    if [[ $# -gt 0 ]]; then
        local vers="$1"
        case "$vers" in
          -) cd "$APPL_TOP"; return 0 ;;

          +([0-9])+(.+([0-9]))*([a-z])) vers="rel-$vers" ;;
          +([0-9])*([a-z]))             vers="tod-$vers" ;;
        esac

        export APPL="$APPL_TOP/$vers"
    fi

    [[ -n "$target" ]] && clear
    [[ -z "$nflag" ]]  && cd "$APPL$target" && know_branch >/dev/null 2>/dev/null
    [[ -n "$vflag" ]]  && echo "APPL = $APPL"

    return 0
}  # app


_raily_magic_cd() {
    local top="$1"
    shift
    [[ -z "$APPL" ]]          && { echo >&2 "\$APPL is not defined"; return 1; }
    [[ -d "$APPL/app" ]]      || { echo >&2 "\$APPL does not appear to be a Rails project"; return 1; }
    [[ -d "$APPL/app/$top" ]] || { echo >&2 "\$APPL does not have an app/$top directory";   return 1; }

    cd "$APPL/app/$top"
}   # _raily_magic_cd


M() { _raily_magic_cd models      "$@"; clear; }
V() { _raily_magic_cd views       "$@"; clear; }
C() { _raily_magic_cd controllers "$@"; clear; }
H() { _raily_magic_cd helpers     "$@"; clear; }
# dang - L is already taken
P() { _raily_magic_cd public      "$@"; clear; }


know_branch

