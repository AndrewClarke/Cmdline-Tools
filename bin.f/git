
know_branch() {
    export BRANCH="$(command git 2>/dev/null branch --list | sed -n 's/^\* //p')" >/dev/null 2>/dev/null
    [[ -r "$APPL/config/database.yml" ]] && eval $(perl -ne 'print "export DBNAME=$1\n" if (/^development:/ ... /^\S/) && /^\s+database:\s*(\w+)/' "$APPL/config/database.yml") >/dev/null 2>/dev/null
}  # know_branch


git() {
    local call=git result=0 loopable= iflag= at_top=

    if [[ "$PWD" == "$APPL_TOP" ]]; then
        at_top=1
        tops=(@(rel-+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z])))
    fi

    while true; do
        if [[ "X$1" == X-i ]]; then
            iflag=1
            shift
            continue
        fi

        if [[ -n "$at_top" && "X$1" == X-L ]]; then
            shift
            tops=()
            while [[ "$1" == @(rel-+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z])) ]]; do
                tops+=("$1")
                shift
            done
            continue
        fi

        break
    done

    if [[ "$1" != help && "$2" == help ]]; then
        echo >&2 "You probably mean git $(tput setaf 3)$1 --help ...$(tput sgr0) or $(tput setaf 3)git help $1 ...$(tput sgr0)"
        call= result=1
    elif [[ "$1" == @(huh|status|fetch|push|pull|pulla|jones) ]]; then
        loopable=1
    elif [[ "$1" == branch ]]; then
        if [[ $# -eq 1 ]] || [[ $# -eq 2 && "X$2" == X-a ]]; then
            loopable=1
        fi
    fi

    if [[ -n "$at_top" && -n "$loopable" ]]; then
        local HERE="$PWD"
        local OAPPL="$APPL"
        trap 'cd "$HERE"; [[ -n "$OAPPL" ]] && app -n "${OAPPL##*/}"' RETURN HUP INT QUIT TERM

        local _first=1
        for _d in "${tops[@]}"; do
            [[ -d "$HERE/$_d" ]] || continue
            [[ "$1" != @(status|branch) && -f "$HERE/$_d/.gitskip" ]] && continue

            if [[ -n "$iflag" ]]; then
                while
                  read -p "Perform git $1 on $_d? " || { echo; break 2; }
                  case "$REPLY" in
                    [yY]*) break;;
                    [nN]*) continue 2;;
                    [qQ]*) break 2;;
                  esac
                do
                    echo "Make a choice!"
                done
            fi

            cd "$HERE/$_d" || continue

            ((_first)) || echo
            _first=0
            echo '$APPL_TOP/'"$_d:"
            git "$@" | sed '/./s/^/  /'
            x=$?
            ((result < x)) && result=$x
            cd "$HERE"
        done

        return $result
    fi

    case "$1" in
      huh)
        shift
        set -- status "$@" .
        ;;

      pulla)
        shift
        ## command git stash save "preparing to have a big pull"

        command git branch | sed 's/^ /-/' | {
            this=
            while read state name; do
                [[ $state == '*' ]] && this="$name"
                ( command git checkout "$name" && command git pull "$@" )
            done
            [[ -n "$this" ]] && command git checkout "$this" 2>&-
        }

        ## command git stash pop

        call= result=0
        ;;

      jones)      # as in, keeping up with...
        call=
        result=0

        command git branch | sed 's/^ /-/; s/^\(.\) \(.*\)/\2 \1/' | sort | {
            typeset -a branches
            this=

            while read name state; do
                [[ "$state" == '*' ]] && this="$name"
                branches+=("$name")
            done

            main="${branches[0]}"
            dev="${branches[1]}"
            if [[ "${#branches[@]}" -eq 2 && "$this" == tod-+([0-9])*([a-z]) ]] && [[ "$main" == rel-+([0-9])+(.+([0-9]))*([a-z]) && "$dev" == tod-+([0-9])*([a-z]) ]]; then
                # proven:
                #  this directory only has 2 local branches: a release (branch it's following) and a development branch
                #  current branch is the development branch

                if git status --porcelain | sed 's/^ /./; s/^\(.\)\(.\) \(.*\)$/\1 \2 \3/; /^[?!]/d' | grep -q .; then
                    echo >&2 "Significant uncommitted work exists - cannot merge release $main"
                else
                    echo "Merging from origin/$main"
                    git merge -X patience "origin/$main"
                fi
            fi
        }
        ;;

      branch)
        if [[ "$2" == @(list|merge|merged|track|delete|move|rename) ]]; then
            echo >&2 "Not allowing $(tput setaf 3)git branch $2$(tput sgr0)! Do you mean one of --list --merged --track -d -D -M -m ?"
            call= result=1
        fi
        ;;

      ls)
        shift
        call=
        ls "$@" $(command git status --porcelain | perl -ne 'chomp; print "$2\n" if /^([MADRCU].|.[MADRCU]) (.*)$/;' | sort -u)
        ;;


      stash)
        if [[ "$2" != @(list|show|drop|pop|apply|branch|save|clear|create) ]]; then
            echo >&2 "Not allowing $(tput setaf 3)git stash$(tput sgr0) without a sub-command! Do you mean list, show or save, or do you mean drop, pop, apply, branch, clear or create?"
            call= result=1
        fi

        ## if [[ "$2" == save ]] && [[ $# -lt 3 || ${!#} == -* ]]; then
        ##     echo >&2 "Try putting a message that means something to you, tiger!"
        ##     call= result=1
        ## fi
        ;;
    esac

    if [[ -n "$call" ]]; then
        command $call "$@"
        result=$?
    fi

    know_branch >/dev/null 2>/dev/null
    return $result
}  # git


app_usage() {
   echo >&2 "usage: app [-l] [-n] [-v] [-N] [-M|-V|-C|-H] [project]"
   [[ $# -gt 0 ]] && echo >&2 "$@"
   return 1
}  # app_usage


app() {
    local nflag= vflag= lflag= Nflag=
    local Mflag= Vflag= Cflag= Hflag= OPTIND=1

    while getopts :lnvNMVCH ch; do
      case "$ch" in
        l) lflag=1 ;;   # list available apps
        n) nflag=1 ;;   # no move - just echo or set
        v) vflag=1 ;;   # verbalise
        N) Nflag=1 ;;   # go Native - make the current branch match the project

        [MVCH]) eval ${ch}flag=${ch} ;;

        *) app_usage; return
      esac
    done
    shift $((OPTIND-1))

    case "$Mflag$Vflag$Cflag$Hflag" in
      ??*)
        app_usage "-M, -V, -C, and -H are mutually exclusive"; return
    esac

    if [[ -n "$nflag" && -n "$Mflag$Vflag$Cflag$Hflag" ]]; then
        app_usage "Cannot use -n with -M, -V, -C, or -H"; return
    fi

    if [[ -z "$APPL_TOP" ]]; then
        app_usage "Cannot find \$APPL_TOP environment variable"; return
    fi

    if [[ ! -d "$APPL_TOP" ]]; then
        app_usage "Cannot find $APPL_TOP directory"; return
    fi

    if [[ -n "$lflag" ]]; then
        if [[ -n "$nflag$Nflag" || $# -gt 0 ]]; then
            app_usage "Cannot use -l with -n, -N or a named project"; return
        fi

        ls 2>&- -d "$APPL_TOP"/@(rel-+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z])) | sed 's:.*/::' |
        {
          first=yo
          while read app; do
              if [[ -z "$vflag" ]]; then
                  echo $app
              else
                  if [[ -n "$first" ]]
                    then first=
                    else echo
                  fi

                  echo "$app:"
                  ( \cd "$APPL_TOP/$app" && git branch | sed 's/^/  /' )
              fi
          done
        }

        return 0
    fi

    if [[ -n "$Nflag" ]]; then
        if [[ -n "$nflag$vflag" || $# -gt 0 ]]; then
            app_usage "Cannot use -N with -n or a named project"; return
        fi

        if [[ "$PWD" != "$APPL_TOP"/@(rel-+([0-9])+(.+([0-9]))*([a-z])|tod-+([0-9])*([a-z]))?(/*) ]]; then
            app_usage "'app -N' only works if you are in a Tickit project"; return
        fi

        local xxx="${PWD#$APPL_TOP/}"
        xxx="${xxx%%/*}"
        git checkout -m "$xxx"
        return 0
    fi

    target=
    case "$Mflag$Vflag$Cflag$Hflag" in
      M) target=/app/models      ;;
      V) target=/app/views       ;;
      C) target=/app/controllers ;;
      H) target=/app/helpers     ;;
    esac

    if [[ $# -gt 0 ]]; then
        local vers="$1"
        case "$vers" in
          -) cd "$APPL_TOP"; return 0 ;;

          +([0-9])+(.+([0-9]))*([a-z])) vers="rel-$vers" ;;
          +([0-9])*([a-z]))             vers="tod-$vers" ;;
        esac

        export APPL="$APPL_TOP/$vers"
    fi

    [[ -n "$target" ]] && clear
    [[ -z "$nflag" ]]  && cd "$APPL$target" && know_branch >/dev/null 2>/dev/null
    [[ -n "$vflag" ]]  && echo "APPL = $APPL"

    return 0
}  # app


_raily_magic_cd() {
    local top="$1"
    shift
    [[ -z "$APPL" ]]          && { echo >&2 "\$APPL is not defined"; return 1; }
    [[ -d "$APPL/app" ]]      || { echo >&2 "\$APPL does not appear to be a Rails project"; return 1; }
    [[ -d "$APPL/app/$top" ]] || { echo >&2 "\$APPL does not have an app/$top directory";   return 1; }

    cd "$APPL/app/$top"
}


M() { _raily_magic_cd models      "$@"; clear; }
V() { _raily_magic_cd views       "$@"; clear; }
C() { _raily_magic_cd controllers "$@"; clear; }
H() { _raily_magic_cd helpers     "$@"; clear; }


know_branch

